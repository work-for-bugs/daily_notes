# 普通二叉树解法
后序遍历   
```c++ {.line-numbers}
int getNodeNum(TreeNode* root) {
    if(!root)
        return 0;
    int left = getNodeNum(root->left); 
    int right = getNodeNum(root->right);
    return left + right + 1;
}
```
# 完全二叉树的思路
利用完全二叉树的特性，看子树，如果子树是满二叉树，那么子树的节点数就是2^h - 1，否则，继续向下递归。   
如何判断是否是满二叉树呢？一直向左遍历，记录深度，一直向右遍历，记录深度。如果两个深度相等则是满二叉树。   
最后返回左子树+右子树+1   
# 代码实现
```c++ {.line-numbers}
int getNodeNum(TreeNode* root) {
    // 终止条件
    if(!root)
        return 0;
    left = root->left;
    right = root->right;
    leftDepth = 0;
    rightDepth = 0;
    while(left){
        left = left->left;
        leftDepth++;
    }
    while(right){
        right = right->right;
        rightDepth++;
    }
    if(leftDepth == rightDepth)
        return (2<<leftDepth)-1;//位运算，左移一位表示*2
    
    // 单层递归逻辑
    leftNum = getNodeNum(root->left);
    rightNum = getNodeNum(root->right);
    return leftNum + rightNum + 1;
}
```
