将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记   
如何标记：要处理的节点放入栈之后，紧接着放入一个空指针作为标记   
```c++ {.line-numbers}
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> st;
    if (root == nullptr) 
        st.push(root); 
    while (!st.empty()) {
        TreeNode* cur = st.top();
        if (cur != nullptr) {
            st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
            if (cur->right != nullptr) 
                st.push(cur->right); // 添加右节点（空节点不入栈）
            st.push(cur); //         // 添加中节点
            st.push(nullptr);        // 中节点访问过，但是还没有处理，加入空节点做为标记
            if (cur->left != nullptr) 
                st.push(cur->left); // 添加左节点（空节点不入栈）
        }
        else {  // 只有遇到空节点的时候，才将下一个节点放进结果集
            st.pop();   // 将空节点弹出
            cur = st.top(); // 重新获取栈顶元素
            st.pop();
            res.push_back(cur->val);  // 加入到结果集
        }
    }
    return res;
}
```

前序   
中左右  放在代码里是右左中   
```c++ {.line-numbers}
vector<int> inorderTraversal(TreeNode* root) {
    vector<int> res;
    stack<TreeNode*> st;
    if (root == nullptr) 
        st.push(root); 
    while (!st.empty()) {
        TreeNode* cur = st.top();
        if (cur != nullptr) {
            st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
            if (cur->right != nullptr) 
                st.push(cur->right); // 添加右节点（空节点不入栈）
            
            if (cur->left != nullptr) 
                st.push(cur->left); // 添加左节点（空节点不入栈）

            st.push(cur); //         // 添加中节点
            st.push(nullptr);        // 中节点访问过，但是还没有处理，加入空节点做为标记
        }
        else {  // 只有遇到空节点的时候，才将下一个节点放进结果集
            st.pop();   // 将空节点弹出
            cur = st.top(); // 重新获取栈顶元素
            st.pop();
            res.push_back(cur->val);  // 加入到结果集
        }
    }
    return res;
}
```