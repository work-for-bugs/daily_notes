# 思路&遍历顺序
前序遍历   
也可以迭代法   
# 为什么会有回溯
收集路径，收集某路径之后，弹出原来的节点   
# 代码实现
```cpp{.line-numbers}
void traverse(Treenode* node, vector<int>& path, vector<string>& result){
    // 中
    path.push_back(node->val); // 到叶子节点就结束了，结束前要把节点放到数组里

    // 终止条件 遍历到叶子节点
    if(node->left == NULL && node->right == NULL)
        result.push_back(path); // 要转格式

    // 单层处理逻辑 前序 中左右
    // 左
    if(node->left){
        traverse(node->left, path, result);
        path.pop_back(); //回溯
    }
    // 右
    if(node->right){
        traverse(node->right, path, result);
        path.pop_back(); //回溯
    }
}
```
# 总结
有精简版本，隐藏了回溯   


