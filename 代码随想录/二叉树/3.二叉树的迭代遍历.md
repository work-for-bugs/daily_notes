# 前序遍历非递归
这里空节点不入栈   
```c++ {.line-numbers}
vector<int> function(TreeNode* root) {
    stack<node> st;
    vector<int> res;
    st.push(root);
    while(!st.empty()) {
        node = st.top();
        st.pop();
        if(node) {
            res.push_back(node->val);
        }
        else
            continue;
        // 先将右孩子入栈，再将左孩子入栈，才能是根左右的遍历顺序
        st.push(node->right);
        st.push(node->left);
    }
    return res;
}
```

# 后序遍历非递归
前序：中左右。把压栈的顺序改为左右，就变成了中右左。再把数组反转就变成了左右中的后序   

# 中序遍历非递归
中序遍历的特殊之处在于：访问的顺序和要处理的顺序不一样   
有左节点存入左节点，无左节点弹出，存入右节点。右为空弹出该节点的父节点   
```c++ {.line-numbers}
vector<int> traversal(TreeNode* root) {
    vector<int> res;
    stack<node> st;
    node* cur = root;
    while(cur || !st.empty()) {
        if(cur){
            st.push(cur);
            cur = cur->left;
        }
        else {
            cur = st.top();
            st.pop();
            res.push_back(cur->val);
            cur = cur->right;//遍历当前指针的右孩子
        }
    }
    return res;
}
```
用指针来遍历节点，用栈来记录遍历的元素   

