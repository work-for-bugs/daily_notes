# 整体思路
大顶堆 小顶堆   
堆  特别擅长在很大的一个数据集里 求前k个高频或低频的操作   
哈希表统计频率，小顶堆维护前k个元素，最后输出   
小顶堆的排序操作是logk 的时间复杂度   
总的时间复杂度是O(nlogk)   
# 代码实现
```c++ {.line-numbers}
for(int i=0;i<nums.size();i++) {
    map[nums[i]]++;
}
priority_queue(<key, value> cmp());
for(map : it) {
    que.push(it);
    if(que.size() > k) {
        que.pop();
    }
}
vector<int> res;
for(i = k-1;i>=0;i--) {
    res[i] = que.top().first;
    que.pop();
}
return res;
```

```c++ {.line-numbers}
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> map;
        for(int i = 0; i < nums.size(); i++) {
            map[nums[i]]++;
        }

        // 定义一个小顶堆
        priority_queue<pair<int,int>, vector<pair<int, int>>, ValueComparator> que;
        // 遍历map
        for(const auto& it : map) {
            que.push(it);
            if(que.size() > k)
                que.pop();
        }

        // 将小顶堆输出到vector
        vector<int> ans;
        for(int i = 0; i < k; i++) {
            ans.push_back(que.top().first);
            que.pop();
        }
        return ans;
    }
    // 定义map比较value的比较类
    struct ValueComparator{
        bool operator() (const pair<int, int>& a, const pair<int, int>& b) {
            return a.second > b.second;
        }
    };
};
```