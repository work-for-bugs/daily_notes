# 移动匹配
ss=s+s   
ss.erase(首，尾)   
ss.find(s)   
```c++ {.line-numbers}
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        string t = s + s;
        t.erase(t.begin());
        t.erase(t.end()-1);
        return t.find(s)==std::string::npos?false:true;
    }
};
```

# KMP解法
先求整个字符串的next数组，然后判断next数组最后一位是否为0，即是否有相等前后缀。然后看字符串长度是否能整除相等前后缀之外的子串长度。   
```c++ {.line-numbers}
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        //求s的最长相等前后缀，即next数组的最后一位
        int j = 0;
        int n = s.size();
        vector<int> next(n);
        next[0] = 0;
        for(int i = 1; i < n; i++){
            while(j > 0 && s[i] != s[j]){
                j = next[j-1];
            }
            if(s[i] == s[j])
                j++;
            next[i] = j;
        }
        int len = n - next[n-1];
        return n % len == 0 && next[n-1] != 0;
    }
};
```


